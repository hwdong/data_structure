**Maximum Subarray**  
Given an array of integers,  
find a contiguous subarray which has the largest sum.  

Example  
Given the array [−2,2,−3,4,−1,2,1,−5,3],  
the contiguous subarray [4,−1,2,1] has the largest sum = 6.

Note  
The subarray should contain at least one number.

Challenge  
Can you do it in time complexity O(n)?  

```
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std; 

/*  
用Sub表示当前子数组和，maxSub表示求得的最大子数组和。当Sub <= 0时，累加数组中的元素只会使得到的和更小，故此时应将此部分和丢弃，  
使用此时遍历到的数组元素替代。需要注意的是由于有maxSub更新sub, 故直接丢弃小于0的sub并不会对最终结果有影响。 
即不会漏掉前面的和比后面的元素大的情况。
*/
int MaximumSubarray(vector<int>& nums) {
	int maxSub = INT_MIN,Sub= 0;
	for (auto a : nums) {
		Sub = max(Sub +a, a);
		maxSub = max(maxSub, Sub);
	}
	return maxSub;
}

//  max{ 前缀和 - 最小前缀和}
int MaximumSubarray_(vector<int>& nums) {
	int sum = 0, minsum = 0,maxSub = INT_MIN;
	for (auto a : nums) {		
		sum += a;
		maxSub = max( maxSub ,sum - minsum );
		minsum = std::min(minsum, sum);
	}
	return maxSub;
}

int main() {
	vector<int> nums = {-2, 2,-3, 4, -1, 2, 1,-5, 3 };
	std::cout << MaximumSubarray(nums) << std::endl;
	std::cout << MaximumSubarray_(nums) << std::endl;
	return 0;
}

//http://www.kancloud.cn/kancloud/data-structure-and-algorithm-notes/73086
```
